# New 3DS microSD Management — SMB1 Exploits & Discoveries

Findings from reverse-engineering the SMB1 file server exposed by the
New Nintendo 3DS "microSD Management" feature (System Settings → Data
Management → microSD Management). The server listens on TCP port 139
only; port 445 is closed.

---

## 1. SPNEGO Authentication Bypass

**What:** The 3DS accepts any SPNEGO NTLM Type 1 blob and immediately
returns `STATUS_SUCCESS` with uid=0. No Type 2 challenge is issued, no
credentials are verified.

**Why it matters:** Authentication can be reduced to a single hardcoded
66-byte blob. No username, password, domain, or NTLM handshake is
needed.

**Details:**

The Session Setup AndX (`0x73`) carries a standard SPNEGO wrapper
containing an NTLM Type 1 message. The 3DS never inspects the content —
it does not send a Type 2 challenge and does not expect a Type 3
response. The blob we use:

```
6040 0606 2b06 0105 0502 a036 3034 a00e
300c 060a 2b06 0104 0182 3702 020a a222
0420 4e54 4c4d 5353 5000 0100 0000 0502
08a0 0000 0000 0000 0000 0000 0000 0000
0000 00
```

This is a generic NTLM Type 1 with no workstation or domain strings.
Any variation also works — the server does not parse past the SPNEGO OID.

---

## 2. SMB_COM_DELETE and SMB_COM_RENAME — Unicode Alignment Gotcha

**What:** `SMB_COM_DELETE` (`0x06`) and `SMB_COM_RENAME` (`0x07`) both
**work correctly** when the wire format uses the right Unicode string
encoding. Earlier testing incorrectly concluded they were broken due to
a subtle BufferFormat padding error.

**Why it matters:** Native DELETE and RENAME are single-operation
commands — far more efficient than the workarounds previously used
(DELETE via `NT_CREATE_ANDX` + `FILE_DELETE_ON_CLOSE`, RENAME via
copy + delete).

**The bug that led to the "broken" conclusion:** The `BufferFormat`
byte (`0x04`) must be immediately followed by the UTF-16LE string
with **no padding byte** for the first string in both commands. For
the second string in RENAME, a padding byte **is** required after the
`BufferFormat` byte when the string would otherwise start at an odd
offset relative to the SMB header. Adding an incorrect padding byte to
the first string, or omitting the required one before the second
string, produces `STATUS_OBJECT_NAME_NOT_FOUND` — which looks like
the file doesn't exist when really the server can't parse the name.

**Correct DELETE wire format (0x06):**

```
WordCount = 1
SearchAttributes = 0x0006      (hidden + system — include all file types)
ByteCount = ...
BufferFormat = 0x04             (no padding after this byte!)
FileName = UTF-16LE + 0x00 0x00
```

**Correct RENAME wire format (0x07):**

```
WordCount = 1
SearchAttributes = 0x0006
ByteCount = ...
BufferFormat1 = 0x04            (no padding — offset 38 from header is even)
OldFileName = UTF-16LE + 0x00 0x00
BufferFormat2 = 0x04
PadByte = 0x00                  (IF next position is odd — required for alignment)
NewFileName = UTF-16LE + 0x00 0x00
```

The alignment rule: after each `BufferFormat` byte (`0x04`), if the
next byte position (where the UTF-16LE string would begin) is at an
**odd** offset from the start of the SMB header, insert one `0x00`
padding byte before the string data.

**What doesn't work:**

| Method | Result |
|--------|--------|
| `SMB_COM_DELETE` with padding after first `0x04` | `STATUS_OBJECT_NAME_NOT_FOUND` |
| `SMB_COM_DELETE` without `BufferFormat` byte | `STATUS_OBJECT_NAME_NOT_FOUND` |
| `SMB_COM_DELETE` in ASCII mode (FLAGS2 without Unicode) | `STATUS_OBJECT_NAME_NOT_FOUND` |
| `SMB_COM_DELETE` with wildcard patterns (`*.txt`) | `STATUS_OBJECT_NAME_NOT_FOUND` |
| `SMB_COM_RENAME` without alignment padding on second string | `STATUS_DATA_ERROR` (`0xC000003E`) |
| `SMB_COM_NT_RENAME` (`0xA5`) all levels | `STATUS_NOT_SUPPORTED` |
| `SMB_COM_MOVE` (`0x2A`) | `STATUS_NOT_SUPPORTED` |
| `TRANS2_SET_FILE_INFORMATION` level `0x0104` | `STATUS_SUCCESS` but file not renamed (level is `EndOfFile`, not rename) |
| `TRANS2_SET_FILE_INFORMATION` level `0x010A` | `STATUS_NOT_IMPLEMENTED` |
| `TRANS2_SET_PATH_INFORMATION` all levels | `STATUS_NOT_IMPLEMENTED` |
| `NT_TRANSACT_RENAME` (subcmd 5) | `STATUS_ACCESS_DENIED` |

**What works:**

| Method | Result |
|--------|--------|
| `SMB_COM_DELETE` (`0x06`) with correct format | `STATUS_SUCCESS` — file deleted |
| `SMB_COM_RENAME` (`0x07`) with correct format + alignment | `STATUS_SUCCESS` — file renamed |
| `SMB_COM_DELETE` with forward slashes | `STATUS_SUCCESS` |
| `TRANS2_SET_FILE_INFORMATION` level `0x0102` (DispositionInfo) | `STATUS_SUCCESS` — alternative delete via handle |

---

## 3. Tree Connect UNC Name Leniency

**What:** The server name in the Tree Connect AndX UNC path
(`\\NAME\share`) does not cause an error when wrong — any name returns
`STATUS_SUCCESS`. However, only the correct name returns a functional
(non-zero) TID.

**Why it matters:** This is a reliable oracle: send a Tree Connect with
a candidate name and check `tid != 0`. No error handling needed — just
inspect the TID field. This is the basis for the pipelined name
discovery in finding #5.

**Details:**

```
\\WRONG\microSD  →  STATUS_SUCCESS, tid=0 (stub, can't list files)
\\3DS-XXXX\microSD  →  STATUS_SUCCESS, tid=6 (functional)
```

A tid of 0 looks valid but any TRANS2 or file operation using it fails.
Only the correct NetBIOS name yields a usable tree ID.

---

## 4. NetBIOS Called Name Length Byte Bypass

**What:** The 3DS NetBIOS session handler uses the "called name" length
byte to decide how many encoded characters to validate. By setting it
to `0x1E` instead of the standard `0x20`, the server skips enough
validation to accept any name.

**Why it matters:** A client can establish a NetBIOS session without
knowing the 3DS's name at all. Combined with finding #3, this enables
fully anonymous, name-free connections.

**Details:**

In a standard NetBIOS Session Request (type `0x81`), the called name
field is:

```
[length=0x20] [32 bytes of level-2-encoded name] [0x00]
```

The 32 encoded bytes represent 16 decoded characters (15 name chars +
1 suffix byte), where each character is split into two nibble-encoded
bytes (each nibble + `0x41`).

The 3DS behavior by length byte value:

| Length byte | Behavior |
|-------------|----------|
| `0x01`–`0x1E` | Accepts **any** called name (insufficient chars checked) |
| `0x1F` | Checks the suffix byte; rejects mismatches |
| `0x20` | Full validation — standard behavior, rejects wrong names |
| `0x21`+ | Connection silently dropped/times out |
| `0x400`+ (1024+ byte names) | Connection reset (`RST`); server does **not** crash |

Setting the length byte to `0x1E` is the sweet spot — it passes
validation for any name while keeping the encoded payload at standard
length, so no other framing is disturbed.

**Reliability warning:** This bypass is **non-deterministic**. In
extended testing, the bypass sometimes works and sometimes does not —
all length bytes `0x01`–`0x1E` can be refused with error code `0x80`
("Not listening on called name") under identical conditions to when
they previously succeeded. The bypass tends to fail after a fresh 3DS
restart and may begin working after the device has been running for
some time, but the exact conditions are not understood. **This bypass
cannot be relied upon for production code.**

**Overflow note:** Sending names far exceeding the standard 32 encoded
bytes (tested up to 2048 bytes) does not crash the 3DS. The server
drops the TCP connection with a RST for very large payloads but
continues serving new connections normally. Earlier apparent "crashes"
during testing were caused by rapid connection flooding (~dozens of
connects in quick succession), not by oversized name payloads. The 3DS
is single-threaded and overwhelms easily under connection storms but
recovers on its own.

---

## 5. Pipelined Name Discovery

**What:** Combining findings #3 and #4, we can discover the 3DS's
name by pipelining 10,000 Tree Connect requests (for names `3DS-0000`
through `3DS-9999`) over a single authenticated session.

**Why it matters:** Eliminates the need to know or configure the 3DS
name. Average discovery time is ~4 seconds, worst case ~10 seconds.

**Reliability warning:** This technique depends on finding #4 (the
`0x1E` length byte bypass) to establish a session without knowing the
name. Since the bypass is non-deterministic (see finding #4), pipelined
name discovery is equally unreliable. Additionally, the 3DS name can
be set to **any arbitrary string** (not just `3DS-NNNN`), making the
10,000-candidate brute-force only viable for the default naming scheme.
**For reliable name discovery, see finding #10 (passive network
discovery).**

**Details:**

Procedure:
1. Connect with NetBIOS length byte `0x1E` (bypass name check)
2. Negotiate + authenticate (both succeed without a valid name)
3. Send batches of 500 Tree Connect requests pipelined — all 500 SMB
   frames written to the socket in one `sendall()`, then read 500
   responses sequentially
4. For each response, check `tid != 0`; first hit reveals the name
   via the MID (message ID) correlation
5. Drain remaining responses in the winning batch, stop

Performance constraints:
- The 3DS processes ~1,000 SMB requests per second regardless of
  client-side parallelism (it is single-threaded)
- Multiple concurrent TCP connections do not help — the 3DS only
  handles one connection at a time; a second connection causes the
  first to be reset
- Batch size of 500 was chosen empirically; larger batches risk
  socket buffer overflow on the 3DS side
- Worst case: all 10,000 names checked = 20 batches × 500 = ~10s

---

## 6. Zero-Length Session Request Crash (Remote DoS)

**What:** Sending a NetBIOS Session Request (type `0x81`) with a
payload length of zero — just 4 bytes: `81 00 00 00` — to TCP port 139
crashes the microSD Management app instantly.

**Why it matters:** This is a pre-authentication, zero-interaction
remote denial-of-service. Any device on the same Wi-Fi network can kill
the file server with a single 4-byte TCP payload. No NetBIOS session,
no SMB negotiation, no credentials — just a raw TCP connect and send.

**Minimal PoC:**

```python
import socket
s = socket.socket()
s.connect(("<3DS_IP>", 139))
s.send(b"\x81\x00\x00\x00")
```

**Details:**

The crash triggers when the effective payload length resolves to 0
for a type `0x81` message. Two known crash payloads:
- `81 00 00 00` — length = 0 (standard encoding)
- `81 80 00 00` — E flag set (bit 7 of flags byte), but length
  portion is still 0

Tested variations that do NOT crash:

| Payload | Why it survives |
|---------|----------------|
| `81 00 00 01 00` | length=1, server reads 1 byte of payload, rejects name |
| `81 01 00 00` | E flag = length 0x10000, server blocks waiting for 64K of data |
| `81 FF 00 00` | Huge implied length, server blocks waiting |
| `82/83/84/85 00 00 00` | Not type 0x81 — server ignores or discards |
| `00 00 00 00` | Session Message type, length 0 — ignored |
| `81 00 00` (3 bytes) | Incomplete NBSS header — server blocks on recv |
| `81 00 00 00` + immediate RST | RST arrives before server processes |

**Reproduced:** 5/5 attempts, 100% reliable. The crash triggers the
3DS system-level exception handler, which displays:

> Ein Fehler ist aufgetreten. Die Software wurde beendet.
> Das System wird nun neu gestartet.
> (An error has occurred. The software has been terminated.
> The system will now restart.)

This is the ARM11 userland unhandled-exception dialog — the OS kernel
caught a data abort (segfault) from the System Settings applet and
force-terminated it. The entire System Settings process restarts, not
just the SMB server. The user must navigate back to Data Management →
microSD Management to restart the server. No crash dump files are
written to the SD card.

**Timing:** The crash is synchronous — it occurs during NBSS header
processing before any further `recv()`. Sending follow-up data after
the 4-byte header (even with zero delay, TCP_NODELAY, or split writes)
does not prevent the crash. The server never reads the follow-up data.

**Connection stealing:** A second TCP connection to port 139 is
accepted even when an existing SMB session is active. Sending the
crash payload on the second connection kills the server, terminating
both the attacker's and the legitimate client's sessions. This is a
reliable way to force-disconnect any active SMB client.

**Root cause analysis:** The Session Request handler reads the called
name length byte at offset 0 of the payload buffer. With zero-length
payload, this is an out-of-bounds read. The server does:

```
header = recv(4)          // reads type=0x81, flags, length_hi, length_lo
length = (flags & 1) << 16 | length_hi << 8 | length_lo  // = 0
buf = recv(length)        // reads 0 bytes
called_name_len = buf[0]  // OOB read → crash
```

The fact that length=1 with any content survives (even `0x00`)
confirms the bug is specifically in the zero-length edge case. The
server does not check `length > 0` before indexing into the buffer.

**Exploitability assessment — DoS only, not code execution.**

Extensive testing was performed to determine if this crash can be
leveraged beyond denial-of-service:

| Technique | Result |
|-----------|--------|
| Heap spray before crash | No effect — always clean segfault |
| Inject TCP data after `81 00 00 00` | Server never reads it (crash is synchronous) |
| Split TCP write (header then payload) | Still crashes before reading follow-up |
| Port scan during restart window | No new ports — 3DS goes dark, comes back with only 139 |
| Filesystem corruption via crash mid-write | FAT writes are synchronous; all files intact after crash |
| Repeated rapid crashing | Same behavior every time; no state degradation |

The crash is a **null/unmapped memory read** (not a write), so memory
cannot be corrupted. The ARM11 kernel exception handler terminates the
process cleanly. No crash dumps or state artifacts are written to the
SD card. No new services or ports become accessible during the restart
window.

**Practical uses:**
1. Remote kill switch — 4 bytes kills the SMB server from anywhere on
   the same WiFi network
2. Session disruption — a second TCP connection is accepted while a
   session is active; the crash payload kills both connections, letting
   an attacker force-disconnect a legitimate user
3. Denial of service — crash it faster than the user can navigate back
   through System Settings → Data Management → microSD Management

---

## 7. Miscellaneous Findings

**Single connection limit (partially wrong):** The 3DS was previously
thought to only accept one TCP connection, resetting the first when a
second arrives. In fact, a second TCP `connect()` to port 139 succeeds
while an existing session is active — the TCP three-way handshake
completes. However, the second connection cannot establish a NetBIOS
session (the first session must close first). The crash exploit
(finding #6) works on the second connection, killing the server and
both connections.

**No other services (at rest):** When no startup activity is
occurring, port scans reveal only TCP 139. Port 445 (direct SMB),
port 80 (HTTP), mDNS (5353) are all closed. The 3DS does not respond
to inbound NBNS queries (UDP 137 unicast or broadcast), making
traditional NetBIOS name resolution via query impossible. However, the
3DS *does* actively broadcast on UDP 137, 138, and 3702 during
startup — see finding #10.

**flags2 must be `0xC841`:** This value enables Unicode strings, long
names, and NT status codes. Other values cause silent failures or
garbled responses.

**TRANS2 FIND_FIRST2 search pattern encoding:** The wildcard pattern
(e.g. `\path\*`) must include an explicit `\x00` before UTF-16LE
encoding: `(path + "\\*\x00").encode("utf-16le")`. Omitting the null
causes the 3DS to return zero results.

**Tree Connect service string:** Must be ASCII `?????` (5 question
marks), not UTF-16LE. The 3DS ignores the service type but rejects
malformed encodings.

**File creation (put):** Uses `CreateDisposition=5`
(`FILE_OVERWRITE_IF`), which creates the file if it doesn't exist or
truncates and overwrites if it does. This avoids needing separate
create/overwrite paths.

**Command support sweep (0x00-0xFF):** A full SMB command sweep found
these additional implemented commands beyond the core file workflow:

- `SMB_COM_ECHO` (`0x2B`) returns `STATUS_SUCCESS` (usable keepalive)
- `SMB_COM_LOCKING_ANDX` (`0x24`) returns `STATUS_SUCCESS`
- `SMB_COM_TRANSACTION` (`0x25`) returns `STATUS_SUCCESS`
- `SMB_COM_TREE_DISCONNECT` (`0x71`) and `SMB_COM_LOGOFF_ANDX` (`0x74`)
  return `STATUS_SUCCESS`
- `SMB_COM_FLUSH` (`0x05`), `SMB_COM_WRITE` (`0x0B`),
  `SMB_COM_FIND_CLOSE2` (`0x34`) return `STATUS_INVALID_HANDLE` with
  dummy input, indicating the handlers exist and expect valid IDs

Most undefined command IDs return legacy DOS/SMB errors such as
`STATUS_SMB_BAD_TID`/`STATUS_SMB_BAD_COMMAND` rather than crashing the
service.

**Filesystem info support:** `TRANS2_QUERY_FS_INFORMATION` supports
modern NT-style levels:

- level `0x0103` (FileFsSizeInformation) returns valid total/free size
- level `0x0007` (FileFsFullSizeInformation) returns total/free size
- level `0x0105` (FileFsAttributeInformation) returns attributes and
  max component name length

Legacy level `0x0001` (SMB_INFO_ALLOCATION) returns partially bogus
data on 3DS and should not be used.

**MAC address:** The 3DS uses a Nintendo Co., Ltd. OUI (e.g. `7c:bb:8a`).
Potentially useful for ARP-based discovery on local networks as an
alternative to the pipelined scan.

---

## 8. Dual NTLM Code Paths — Flag-Dependent Authentication Behavior

**What:** The 3DS SMB server has two completely different authentication
code paths depending on the NTLM negotiate flags in the Type 1 message.
Specific flags trigger the full three-step NTLM handshake instead of
the instant-accept shortcut.

**Why it matters:** The SPNEGO auth bypass (finding #1) only works
because our Type 1 flags don't include certain bits. An attacker who
sets the right flags can force the server into the full NTLM negotiation
path, which is where the historical mhax stack overflow vulnerability
lived (patched in 11.8).

**Details:**

| Type 1 Flags | Behavior |
|-------------|----------|
| `0xA0080205` (our default) | `STATUS_SUCCESS` immediately — no Type 2, no Type 3 parsed |
| `0xE2888205` (smea's mhax) | `STATUS_MORE_PROCESSING_REQUIRED` + Type 2 challenge sent |

The key differentiating flags are `NEGOTIATE_ALWAYS_SIGN` (0x8000) and
`NEGOTIATE_128` (0x20000000). When these are present, the server enters
the full NTLM handshake:

1. Client sends Type 1 (negotiate) → Server responds with Type 2
   (challenge containing 8-byte server challenge, e.g. `4fe74708cce98498`)
2. Client sends Type 3 (authenticate) → Server validates and responds
   with `STATUS_SUCCESS` or `STATUS_LOGON_FAILURE`

To trigger this path, send a raw NTLM blob (not SPNEGO-wrapped) with
`Capabilities = 0x80000054` (`CAP_UNICODE | CAP_LARGE_FILES |
CAP_STATUS32 | CAP_EXTENDED_SECURITY`) and `SessionKey = 0`.

smea's mhax exploit (https://github.com/smealum/mhax) used this path
to deliver a stack buffer overflow in the DomainName field of the NTLM
Type 3 message, achieving RCE on firmware <11.8.

---

## 9. NTLM Type 3 Stack Overflow — Fully Patched on 11.17

**What:** Comprehensive fuzzing of all six NTLM Type 3 variable-length
fields confirms that Nintendo patched the buffer overflow across the
board, not just the DomainName field reported by smea.

**Why it matters:** The mhax exploit (CVE not assigned; fixed in
firmware 11.8.0-41) was a stack buffer overflow in the DomainName field
of the NTLM Type 3 message during `SMB_COM_SESSION_SETUP_ANDX`. We
tested whether Nintendo only patched the one reported field or all
fields. Answer: **all fields are safe**.

**Testing methodology:**

Using the dual-path NTLM handshake (finding #8) to force Type 3
processing, we sent 58 test vectors:

*Phase 2 — Oversized fields (48 vectors):*
Each of the 6 Type 3 variable-length fields was tested at sizes
32, 64, 128, 256, 512, 1024, 2048, and 3000 bytes:

| Field | Sizes tested | Result |
|-------|-------------|--------|
| LmResponse | 32–3000 | All survived (`STATUS_LOGON_FAILURE`) |
| NtResponse | 32–3000 | All survived |
| DomainName | 32–3000 | All survived (was the mhax overflow field) |
| UserName | 32–3000 | All survived |
| Workstation | 32–3000 | All survived |
| EncryptedRandomSessionKey | 32–3000 | All survived |

*Phase 3 — Malformed buffer descriptors (10 vectors):*

| Variant | Description | Result |
|---------|-------------|--------|
| oob_offset | DomainName offset=0xFFFF | Survived |
| oob_offset_user | UserName offset=0xFFFF | Survived |
| huge_len | DomainName len=0xFFFF | Survived |
| huge_len_user | UserName len=0xFFFF | Survived |
| negative_offset | DomainName offset=0 (into NTLMSSP header) | Survived |
| overlap_all | All 6 fields point to same offset | Survived |
| zero_all | All fields len=0 offset=0 | Survived |
| maxlen_mismatch | DomainName len=2 maxlen=0xFFFF | Survived |
| truncated | Type 3 header only, no field data | Survived |
| just_signature | Minimal 12-byte Type 3 | Survived |

All 58 vectors returned `STATUS_LOGON_FAILURE` (`0xC000006D`)
consistently. No crashes, no hangs, no connection resets.

**Conclusion:** Nintendo's 11.8 patch added comprehensive bounds
checking to the NTLM Type 3 parser. The server validates buffer
descriptor lengths and offsets before copying field data, preventing
overflows on all fields. The mhax attack vector is fully closed on
firmware 11.17.

---

## 10. Passive Name Discovery — Three Broadcast Protocols

**What:** When microSD Management starts (or the 3DS reconnects to
WiFi), the 3DS broadcasts its NetBIOS name via three independent
protocols: **NBNS name registration** (UDP 137), **CIFS Browser
Host Announcement** (UDP 138), and **WS-Discovery Hello** (UDP 3702).
The name appears in plaintext in the Browser announcement and can be
decoded from the NBNS registration packets.

**Why it matters:** This is a **reliable, zero-authentication** method
to discover the 3DS's name — including arbitrary names, not just the
default `3DS-NNNN` pattern. Unlike finding #5 (pipelined Tree Connect),
this does not depend on the unreliable `0x1E` bypass. Unlike NBNS
queries, which the 3DS ignores, these are unsolicited broadcasts that
the 3DS sends on its own initiative.

**Details:**

The 3DS sends all three broadcast types within seconds of microSD
Management starting. After that, the NBNS and Browser announcements
repeat periodically (Browser announcements observed approximately
every 12 minutes). The WS-Discovery Hello is sent multiple times at
startup (observed 4 copies with incrementing `MessageNumber`).

### Protocol 1: NBNS Name Registration (UDP 137 → broadcast)

The 3DS sends two NBNS registration broadcasts to
`<subnet_broadcast>:137`:

| Registration | Encoded name | Decoded | Suffix |
|-------------|-------------|---------|--------|
| Machine name | (NetBIOS first-level encoded) | `3DS-MYNAME` | `0x20` (file server) |
| Workgroup | `FHEPFCELEHFCEPFFFACACACACACACACABO` | `WORKGROUP` | `0x00` (workstation) |

The encoded bytes use standard NetBIOS first-level encoding (each
byte split into two nibbles, each + `0x41`). The NBNS header has
opcode `5` (REGISTRATION) with the broadcast flag set.

**Decoding algorithm:**

```python
def decode_nb_name(encoded_32):
    """Decode 32 NetBIOS-encoded bytes → (name, suffix)."""
    raw = bytearray()
    for i in range(0, 32, 2):
        raw.append(((encoded_32[i] - 0x41) << 4) | (encoded_32[i+1] - 0x41))
    return raw[:15].decode("ascii").rstrip(), raw[15]
```

**Key observation:** The 3DS does NOT respond to inbound NBNS name
queries (tested unicast and broadcast with wildcard `*` and specific
names). It only sends outbound registration broadcasts. This is why
tools like `nmblookup -A <ip>` and `smbutil status <ip>` fail — they
send queries and wait for responses that never come.

### Protocol 2: CIFS Browser Host Announcement (UDP 138)

The 3DS sends a NetBIOS Datagram (type `0x11`, Direct Group) to
`<subnet_broadcast>:138` containing an SMB `\MAILSLOT\BROWSE`
transaction with a **Host Announcement** (command `0x01`).

The machine name appears **in plaintext** in the Browser announcement
payload, null-terminated, at a fixed offset within the mailslot data:

```
\MAILSLOT\BROWSE  →  01 00 c0 27 09 00  "3DS-MYNAME\x00"
```

The datagram also contains the source and destination NetBIOS names
in standard encoded form in the datagram header.

Announcement fields observed:
- Command: `0x01` (Host Announcement)
- OS Major/Minor: `0x05` / `0x02` (Windows XP era — likely hardcoded)
- Server type: `0x00000009` (Workstation + Server)
- Browser version: `0x0F01`
- Signature: `0x55AA`

### Protocol 3: WS-Discovery Hello (UDP 3702 → multicast)

The 3DS sends SOAP/XML **WS-Discovery Hello** messages to the
WS-Discovery multicast group `239.255.255.250:3702`. This is the
protocol that **modern Windows 10/11** uses for device discovery
(replacing the deprecated Computer Browser service).

Each Hello message is ~988 bytes of XML:

```xml
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope"
               xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
               xmlns:wsd="http://schemas.xmlsoap.org/ws/2005/04/discovery"
               xmlns:wsdp="http://schemas.xmlsoap.org/ws/2006/02/devprof"
               xmlns:pub="http://schemas.microsoft.com/windows/pub/2005/07">
  <soap:Header>
    <wsa:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/Hello</wsa:Action>
    <wsa:MessageID>urn:uuid:...</wsa:MessageID>
    <wsd:AppSequence InstanceId="1" SequenceId="urn:uuid:..." MessageNumber="1"/>
  </soap:Header>
  <soap:Body>
    <wsd:Hello>
      <wsa:EndpointReference>
        <wsa:Address>urn:uuid:48504f43-594d-334b-1fa2-b088436af6c2</wsa:Address>
      </wsa:EndpointReference>
      <wsd:Types>wsdp:Device pub:Computer</wsd:Types>
      <wsd:MetadataVersion>2</wsd:MetadataVersion>
    </wsd:Hello>
  </soap:Body>
</soap:Envelope>
```

The WS-Discovery Hello does **not** contain the NetBIOS name directly
in the XML body, but it identifies the device endpoint UUID and type
(`wsdp:Device pub:Computer`). A WS-Discovery client can then send a
`Resolve` or `Get` request to retrieve the device's metadata,
including its friendly name.

The endpoint UUID (`48504f43-594d-334b-1fa2-b088436af6c2`) is
consistent across restarts and may be derived from hardware
identifiers.

### Bonus: DHCP Hostname

The 3DS also reveals a hostname in its DHCP requests (option 12,
Host Name): `Nintendo 3DS`. This is the generic device type string,
**not** the user-configured NetBIOS name, so it cannot be used for
name discovery. However, it provides another way to identify a 3DS
on the network by inspecting DHCP traffic or the router's DHCP lease
table.

### Practical implementation

For passive-only discovery, the most reliable approach is to **listen
on UDP 138** for Browser Host Announcements from a known Nintendo IP.
The name appears in plaintext, requires no decoding beyond reading a
null-terminated ASCII string from the mailslot payload.

Timing considerations:
- Announcements are sent **immediately** when microSD Management
  starts (within seconds of the WiFi connection completing)
- Subsequent announcements repeat periodically (~12 minutes)
- If the listener starts after the initial burst, it may need to wait
  up to 12 minutes for the next announcement
- Alternatively, listen on UDP 137 for NBNS registrations, which are
  also sent at startup and may repeat more frequently

**Limitation:** This is a passive technique — it requires the 3DS to
broadcast. If the listener starts after the startup burst and cannot
wait for the next periodic announcement, the user prompt fallback
remains necessary.

**For active discovery, see finding #11** — WS-Discovery Probe +
Get retrieves the name on-demand in under 1 second.

---

## 11. Active Name Discovery via WS-Discovery Probe + HTTP Get

**What:** The 3DS implements the full **WS-Discovery** (DPWS) stack,
including an HTTP server on **TCP port 5357** that serves device
metadata. By sending a WS-Discovery Probe multicast, then an HTTP
WS-Transfer Get to the returned XAddrs URL, we can retrieve the
NetBIOS name **on-demand** in under 1 second — no waiting for
broadcasts, no user interaction, no authentication.

**Why it matters:** This is the **definitive name discovery method**.
It works for any arbitrary name, requires no authentication, is
actively triggered (not passive), and completes in ~200ms. It
supersedes findings #4, #5, and #10 as the primary discovery
mechanism.

**Key surprise:** TCP port 5357 is open when microSD Management is
running. Previous port scans only found TCP 139 — port 5357 was
either missed or only opens when the SMB server starts. This is a
full DPWS HTTP endpoint.

**Details:**

### Step 1: WS-Discovery Probe (UDP multicast)

Send a SOAP Probe to `239.255.255.250:3702` for device types
`wsdp:Device pub:Computer`. The 3DS uses the **pre-OASIS 2005/04**
namespace URIs — the Probe must match these exactly or the 3DS will
not respond.

```xml
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope
    xmlns:soap="http://www.w3.org/2003/05/soap-envelope"
    xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
    xmlns:wsd="http://schemas.xmlsoap.org/ws/2005/04/discovery"
    xmlns:wsdp="http://schemas.xmlsoap.org/ws/2006/02/devprof"
    xmlns:pub="http://schemas.microsoft.com/windows/pub/2005/07">
  <soap:Header>
    <wsa:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To>
    <wsa:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action>
    <wsa:MessageID>urn:uuid:{random-uuid}</wsa:MessageID>
  </soap:Header>
  <soap:Body>
    <wsd:Probe>
      <wsd:Types>wsdp:Device pub:Computer</wsd:Types>
    </wsd:Probe>
  </soap:Body>
</soap:Envelope>
```

### Step 2: ProbeMatch (UDP unicast response)

The 3DS responds via **unicast UDP** back to the sender's source
IP:port. The ProbeMatch contains:

- **Endpoint UUID:** `urn:uuid:48504f43-594d-334b-1fa2-b088436af6c2`
- **Types:** `wsdp:Device pub:Computer`
- **XAddrs:** `http://192.168.x.x:5357/48504f43-594d-334b-1fa2-b088436af6c2/`
- **MetadataVersion:** `4`

The **XAddrs** field is the HTTP URL for the device's metadata
endpoint. Note: the Hello message at startup does NOT include XAddrs,
but the ProbeMatch does.

The ProbeMatch does **not** contain the NetBIOS name. Other devices
on the network (e.g. Windows PCs) may also respond; filter by the
known endpoint UUID or by checking that source IP has TCP 139 open.

### Step 3: WS-Transfer Get (HTTP POST)

Send an HTTP POST to the XAddrs URL with a WS-Transfer Get SOAP
envelope:

```xml
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope
    xmlns:soap="http://www.w3.org/2003/05/soap-envelope"
    xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing">
  <soap:Header>
    <wsa:To>urn:uuid:48504f43-594d-334b-1fa2-b088436af6c2</wsa:To>
    <wsa:Action>http://schemas.xmlsoap.org/ws/2004/09/transfer/Get</wsa:Action>
    <wsa:MessageID>urn:uuid:{random-uuid}</wsa:MessageID>
    <wsa:ReplyTo>
      <wsa:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</wsa:Address>
    </wsa:ReplyTo>
  </soap:Header>
  <soap:Body/>
</soap:Envelope>
```

### Step 4: GetResponse (HTTP 200)

The 3DS responds with HTTP 200 containing full device metadata:

```xml
<wsx:Metadata>
  <wsx:MetadataSection Dialect=".../ThisDevice">
    <wsdp:ThisDevice>
      <wsdp:FriendlyName>Nintendo 3DS system</wsdp:FriendlyName>
      <wsdp:FirmwareVersion/>
      <wsdp:SerialNumber/>
    </wsdp:ThisDevice>
  </wsx:MetadataSection>
  <wsx:MetadataSection Dialect=".../ThisModel">
    <wsdp:ThisModel>
      <wsdp:Manufacturer>Nintendo Co., Ltd.</wsdp:Manufacturer>
      <wsdp:ModelName>Nintendo 3DS system</wsdp:ModelName>
      <un0:DeviceCategory>Computers</un0:DeviceCategory>
    </wsdp:ThisModel>
  </wsx:MetadataSection>
  <wsx:MetadataSection Dialect=".../Relationship">
    <wsdp:Relationship Type=".../host">
      <wsdp:Host>
        <wsdp:Types>pub:Computer</wsdp:Types>
        <pub:Computer>3DS-MYNAME/Workgroup:WORKGROUP</pub:Computer>
      </wsdp:Host>
    </wsdp:Relationship>
  </wsx:MetadataSection>
</wsx:Metadata>
```

The **NetBIOS name** is in the `<pub:Computer>` element, format:
`NAME/Workgroup:WORKGROUP`. Parse by splitting on `/`.

The `<wsdp:FriendlyName>` is the generic string `Nintendo 3DS system`,
NOT the user-configured NetBIOS name.

### Device metadata fields

| Field | Value |
|-------|-------|
| FriendlyName | `Nintendo 3DS system` |
| FirmwareVersion | (empty) |
| SerialNumber | (empty) |
| Manufacturer | `Nintendo Co., Ltd.` |
| ModelName | `Nintendo 3DS system` |
| DeviceCategory | `Computers` |
| pub:Computer | `{NetBIOS name}/Workgroup:{workgroup}` |
| Endpoint UUID | `48504f43-594d-334b-1fa2-b088436af6c2` |

### Performance

The full Probe → ProbeMatch → Get → GetResponse flow completes in
under 200ms on a local network. This is faster than any other
discovery method and does not require knowing the name, the IP, or
any credentials.

### Filtering 3DS responses from other devices

Multiple devices on the network may respond to the Probe (any
Windows PC with WS-Discovery enabled will respond). To identify the
3DS:

1. **By endpoint UUID:** The 3DS UUID `48504f43-594d-334b-...`
   appears hardware-derived and stable across restarts. However, other
   3DS devices would have different UUIDs.
2. **By FriendlyName:** Check for `Nintendo 3DS system` in the
   GetResponse metadata.
3. **By Manufacturer:** Check for `Nintendo Co., Ltd.`
4. **By port 139:** After getting the IP from the ProbeMatch source
   address, verify TCP port 139 is open.
